#!/usr/bin/env node
/**
 * Extract translations from translations.ts and write per-locale JSON files + a generated types file.
 *
 * Usage:
 *   1) Install dev deps: npm i -D ts-node typescript
 *   2) Run: node scripts/extract-translations.js
 *
 * This script requires ts-node to be available. It registers ts-node so we can require() TypeScript files
 * (translations.ts imports types.ts etc).
 *
 * Output:
 *   - src/locales/en.json
 *   - src/locales/fa.json
 *   - src/locales/ku.json
 *   - src/locales/ar.json
 *   - src/types/i18n.generated.d.ts
 */
const path = require("path");
const fs = require("fs");

function ensureDir(dir) {
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
}

(async function main() {
  try {
    // Attempt to register ts-node to allow requiring TypeScript files
    // If ts-node is not installed this will throw; see instructions above to install it.
    try {
      require("ts-node").register({ transpileOnly: true });
    } catch (e) {
      console.error("ts-node is required. Install with: npm i -D ts-node typescript");
      process.exit(2);
    }

    const repoRoot = process.cwd();
    const translationsPath = path.resolve(repoRoot, "translations.ts");

    if (!fs.existsSync(translationsPath)) {
      console.error("translations.ts not found at repo root:", translationsPath);
      process.exit(3);
    }

    // Require the translations module (ts-node handles TS)
    const translationsModule = require(translationsPath);
    const translations = translationsModule.translations;
    if (!translations || typeof translations !== "object") {
      console.error("translations export not found or invalid in translations.ts");
      process.exit(4);
    }

    const outLocalesDir = path.resolve(repoRoot, "src", "locales");
    ensureDir(outLocalesDir);

    // Write per-locale JSON files
    for (const [localeKey, messages] of Object.entries(translations)) {
      const fileName = localeKey.toLowerCase() + ".json"; // e.g., EN -> en.json
      const filePath = path.join(outLocalesDir, fileName);
      // Use stable JSON ordering and 2-space indentation
      const json = JSON.stringify(messages, Object.keys(messages).sort(), 2);
      fs.writeFileSync(filePath, json, "utf8");
      console.log("Wrote locale file:", path.relative(repoRoot, filePath));
    }

    // Build type union from keys in the EN base (if present) else union of all keys
    const localeKeys = Object.keys(translations);
    const base = translations.EN ?? translations[localeKeys[0]];
    if (!base || typeof base !== "object") {
      console.error("Unable to determine base locale object for generating MessageKey union.");
    } else {
      const allKeys = Object.keys(base).sort();
      const union = allKeys.map((k) => JSON.stringify(k)).join(" | ");
      const localesUnion = localeKeys.map((k) => JSON.stringify(k.toLowerCase())).join(" | ");
      const typesDir = path.resolve(repoRoot, "src", "types");
      ensureDir(typesDir);
      const outTypesFile = path.join(typesDir, "i18n.generated.d.ts");
      const content = `// This file is auto-generated by scripts/extract-translations.js\n// Do NOT edit by hand. Run the extractor to regenerate.\n\nexport type MessageKey = ${union};\n\nexport type Locale = ${localesUnion};\n\nexport type Messages = { [K in MessageKey]: string };\n`;
      fs.writeFileSync(outTypesFile, content, "utf8");
      console.log("Wrote generated types:", path.relative(repoRoot, outTypesFile));
    }

    console.log("\nExtraction complete. Review files under src/locales and src/types.");
    console.log("Next: integrate src/i18n/LanguageProvider.tsx + messagesLoader.ts into your app and update index.tsx to wrap <LanguageProvider> around <App />.");
  } catch (err) {
    console.error("Extraction failed:", err);
    process.exit(1);
  }
})();
